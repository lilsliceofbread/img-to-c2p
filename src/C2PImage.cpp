#include "C2PImage.hpp"
#include <iostream>
#include <fstream>
#include <algorithm>

#define MAX_WIDTH 0x136
#define MAX_HEIGHT 0x191
#define COLOUR_CHANNELS 3

#define HEADER_LENGTH 0xDC
#define FOOTER_LENGTH 0x17C
#define IMAGE_STARTOFFSET 0xDC

uint8_t ConvertBitRange(uint8_t num,uint8_t original_bit_max, uint8_t new_bit_max) {
    float scale_factor = static_cast<float>(original_bit_max / new_bit_max);
    uint8_t converted_num = static_cast<int>(num / scale_factor);
    return converted_num;

}

C2PImage::C2PImage(const char* image_path, ImageFormat output_format) 
: Image(image_path, COLOUR_CHANNELS, output_format) {
    std::cout << "c2pimage class constructed" << std::endl;

}

bool C2PImage::ConvertToC2P() {
    if(!Resize(MAX_WIDTH, MAX_HEIGHT)) {
        std::cerr << "ERR: image resize failed" << "\n";
        return false;
    }

    m_formatted_image_data = (unsigned char*)malloc(HEADER_LENGTH + (m_width * m_height * 2) + FOOTER_LENGTH);

    if(!ConvertRGB565()) {
        std::cerr << "ERR: image RGB565 conversion failed" << "\n";
        return false;
    }
    if(!CompressData) {
        std::cerr << "ERR: c2pimage compression failed" << "\n";
        return false;
    }
    if(!CreateHeader()) {
        std::cerr << "ERR: c2pimage header creation failed" << "\n";
        return false;
    }   
    
    if(!CreateFooter()) {
        std::cerr << "ERR: c2pimage footer creation failed" << std::endl;
        return false;
    } 
    return true;
}

bool C2PImage::Write(const char* output_filename) {
    std::ofstream output_stream;
    return true;

}

bool C2PImage::ConvertRGB565() {
    //unsafe af function, might be able to use shared_ptr
    int size = m_width * m_height * m_colour_channels;
    m_converted_image_data = (unsigned char*)malloc(size);
    uint8_t red, green, blue;
    uint16_t finalByte;

    for(int i = 0; i < m_height; i++) {
        for(int j = 0; j < m_width; j++) {
            //i moves you down the rows, j moves you across the columns
            int current_index = i * m_width * m_colour_channels + j * m_colour_channels;
            //check if index goes outside pointer, should prevent segfault
            if(current_index + 2 > size) {
                free(m_converted_image_data);
                return false;
            }

            red = m_image_data[current_index];
            green = m_image_data[current_index+1];
            blue = m_image_data[current_index+2];
            
            red = ConvertBitRange(red, 0xFF, 0x1F); //Between 0 and 31
            green = ConvertBitRange(green, 0xFF, 0x3F); //Between 0 and 63
            blue = ConvertBitRange(blue, 0xFF, 0x1F); //Between 0 and 31

            //bitshifting colour values into 2 bytes
            finalByte += red;
            finalByte <<= 11;
            finalByte += green;
            finalByte <<= 5;
            finalByte += blue;

            //new colour channel bytes is 2
            m_converted_image_data[i * m_width * 2 + j * 2] = finalByte;
            std::cout << m_converted_image_data[i * m_width * 2 + j * 2] << " ";
            finalByte = 0;
            red, green, blue = 0;
        }
        std::cout << std::endl;
    }

    return true;
}

bool C2PImage::CompressData() {
    return true;
}

bool C2PImage::CreateHeader() {
    //assert correct length
    unsigned char header[] = {
        
    };
    //if doesn't work check these values
    std::copy(header, header+HEADER_LENGTH-1,  m_formatted_image_data);
    return true;
}

bool C2PImage::CreateFooter() {
    //assert correct length
    int converted_size = m_width * m_height * 2;
    unsigned char footer[] = {
        0x30, 0x31, 0x30, 0x30, 0x00, 0x00, 0x00, 0x8C,
		0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x07, 0x70, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98,
		0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x04, 0x60, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x06, 0x28, 0x31, 0x85,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x06, 0x28, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x09, 0x98, 0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x31, 0x30, 0x30,
		0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01,
		0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x01, 0x03, 0x14, 0x15, 0x93,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x03, 0x14, 0x15, 0x93,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x01, 0x01, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF
    };
    //if doesn't work check these values
    std::copy(footer, footer+FOOTER_LENGTH-1, m_formatted_image_data+HEADER_LENGTH+converted_size-2);
    return true;
}

C2PImage::~C2PImage() {
    
}