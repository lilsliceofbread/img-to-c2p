#include "zlib/zlib.h"

#include <iostream>
#include <fstream>
#include <algorithm>
#include "C2PImage.hpp"

#define MAX_WIDTH 0x136
#define MAX_HEIGHT 0x191
#define COLOUR_CHANNELS 3

#define HEADER_LENGTH 0xDC
#define FOOTER_LENGTH 0x17C
#define IMAGE_STARTOFFSET 0xDC

//putting this function here is a bit cringe but don't know where else
inline uint8_t ConvertBitRange(uint8_t num,uint8_t original_bit_max, uint8_t new_bit_max) {
    float scale_factor = static_cast<float>(original_bit_max / new_bit_max);
    uint8_t converted_num = static_cast<int>(num / scale_factor);
    return converted_num;
}

C2PImage::C2PImage(std::string image_path) 
: Image(image_path, COLOUR_CHANNELS, ImageFormat::PNG), m_compressed_data_size(0) { // format doesn't matter
    std::cout << "c2pimage class constructed" << std::endl;
}

bool C2PImage::ConvertToC2P() {
    if(!Resize(MAX_WIDTH, MAX_HEIGHT)) {
        std::cerr << "ERR: image resize failed" << "\n";
        return false;
    }

    m_formatted_data = (unsigned char*)malloc(HEADER_LENGTH + (m_width * m_height * 2) + FOOTER_LENGTH);

    if(!ConvertRGB565()) {
        std::cerr << "ERR: image RGB565 conversion failed" << "\n";
        return false;
    }
    if(!CompressData()) {
        std::cerr << "ERR: c2pimage compression failed" << "\n";
        return false;
    }
    if(!CreateHeader(m_formatted_data)) {
        std::cerr << "ERR: c2pimage header creation failed" << "\n";
        return false;
    } 
    std::copy(m_converted_image_data, m_converted_image_data+m_compressed_data_size, m_formatted_data+HEADER_LENGTH); 
    if(!CreateFooter(m_formatted_data)) {
        std::cerr << "ERR: c2pimage footer creation failed" << std::endl;
        return false;
    } 
    return true;
}

bool C2PImage::Write(std::string f) {
    std::fstream output_file;
    std::string filename = f + ".c2p";

    output_file.open(filename, std::ios::out | std::ios::binary);
    output_file.write(reinterpret_cast<char*>(m_formatted_data), HEADER_LENGTH + m_compressed_data_size + FOOTER_LENGTH);

    output_file.close();
    std::cout << "wrote c2p file" << std::endl;
    return true;
}

bool C2PImage::ConvertRGB565() {
    //unsafe af function
    int size = m_width * m_height * m_colour_channels;
    m_converted_image_data = (unsigned char*)malloc(sizeof(char) * m_width * m_height * 2);
    uint8_t red, green, blue;
    uint16_t final_byte;
    uint8_t final_byte_1, final_byte_2;

    int current_index, current_converted_index;
    for(int i = 0; i < m_height; i++) {
        for(int j = 0; j < m_width; j++) {
            //i moves you down the rows, j moves you across the columns
            current_index = i * m_width * m_colour_channels + j * m_colour_channels;

            //converted image data has 2 bytes for colour channels 
            current_converted_index = i * m_width * 2 + j * 2;

            //check if index goes outside pointer
            if(current_index + 2 > size) {
                return false;
            }

            red = m_image_data[current_index];
            green = m_image_data[current_index+1];
            blue = m_image_data[current_index+2];
            
            red = ConvertBitRange(red, 0xFF, 0x1F); //Between 0 and 31
            green = ConvertBitRange(green, 0xFF, 0x3F); //Between 0 and 63
            blue = ConvertBitRange(blue, 0xFF, 0x1F); //Between 0 and 31

            //bitshifting colour values into 2 bytes
            final_byte += red;
            final_byte <<= 11;
            final_byte += green;
            final_byte <<= 5;
            final_byte += blue;

            //converting to unsigned char for array
            final_byte_2 = static_cast<unsigned char>(final_byte & 0xFF); //0xFF ensures no numbers on leftmost byte (overflowing bytes?)
            final_byte_1 = static_cast<unsigned char>((final_byte >> 8) & 0xFF); //bitshift right by 1 byte

            //new colour channel bytes is 2
            m_converted_image_data[current_converted_index] = final_byte_1;
            m_converted_image_data[current_converted_index + 1] = final_byte_2;

            final_byte = 0;
            final_byte_1 = 0; 
            final_byte_2 = 0;
            red = 0;
            green = 0;
            blue = 0;
        }
    }
    return true;
}

bool C2PImage::CompressData() {
    int success;
    int data_size = m_width * m_height * 2;
    int alloc_size = (data_size * 1.1) + 12;/*amount we will allocate for compression
                                            110% for nice safety and 12 bytes padding*/
    unsigned char* compressed_image_data = (unsigned char*)malloc(alloc_size);

    success = compress(compressed_image_data, (uLongf*)&alloc_size, m_converted_image_data, data_size);
    switch(success) {
        case Z_OK:
            std::cout << "compression success\n";
            break;
        case Z_MEM_ERROR:
            std::cerr << "ERR: ZLib ran out of memory\n";
            return false;
            break;
        case Z_BUF_ERROR:
            std::cerr << "ERR: ZLib output buffer too small\n";
            return false;
            break;
    }
    free(m_converted_image_data);
    m_compressed_data_size = alloc_size;
    m_converted_image_data = compressed_image_data;
    return true;
}

bool C2PImage::CreateHeader(unsigned char* image_data) {   
    uint32_t file_size = HEADER_LENGTH + m_compressed_data_size + FOOTER_LENGTH;
    if(file_size > 0xFFFFFF) 
        std::cout << "WARNING: file_size > 0xFFFFFF for some reason" << std::endl;
    uint32_t _a = ~(file_size & 0xFFFFFF) & 0xFFFFFF; //&ing prevents non-zero values in top byte
    uint8_t _a1 = (uint8_t)(_a & 0xFF);
    uint8_t _a2 = (uint8_t)((_a >> 8) & 0xFF);
    uint8_t _a3 = (uint8_t)((_a >> 16) & 0xFF);

    uint8_t _b = (0x1D1 - (file_size & 0xFF)) & 0xFF;

    uint32_t _c = file_size - 0x20;
    uint8_t _c1 = (uint8_t)(_c & 0xFF);
    uint8_t _c2 = (uint8_t)((_c >> 8) & 0xFF);
    uint8_t _c3 = (uint8_t)((_c >> 16) & 0xFF);
    uint8_t _c4 = (uint8_t)((_c >> 24) & 0xFF);

    uint32_t _d = file_size - 0x234;
    uint8_t _d1 = (uint8_t)(_d & 0xFF);
    uint8_t _d2 = (uint8_t)((_d >> 8) & 0xFF);
    uint8_t _d3 = (uint8_t)((_d >> 16) & 0xFF);
    uint8_t _d4 = (uint8_t)((_d >> 24) & 0xFF);

    uint32_t _e = file_size - 0x254;
    uint8_t _e1 = (uint8_t)(_e & 0xFF);
    uint8_t _e2 = (uint8_t)((_e >> 8) & 0xFF);
    uint8_t _e3 = (uint8_t)((_e >> 16) & 0xFF);
    uint8_t _e4 = (uint8_t)((_e >> 24) & 0xFF);

    uint16_t _w = m_width & 0xFFFF;
    uint8_t _w1 = (uint8_t)(_w & 0xFF);
    uint8_t _w2 = (uint8_t)((_w >> 8) & 0xFF);
    uint16_t _h = m_height & 0xFFFF;
    uint8_t _h1 = (uint8_t)(_h & 0xFF);
    uint8_t _h2 = (uint8_t)((_h >> 8) & 0xFF);

    uint32_t _f = file_size - 0x258;
    uint8_t _f1 = (uint8_t)(_f & 0xFF);
    uint8_t _f2 = (uint8_t)((_f >> 8) & 0xFF);
    uint8_t _f3 = (uint8_t)((_f >> 16) & 0xFF);
    uint8_t _f4 = (uint8_t)((_f >> 24) & 0xFF);

    unsigned char header[] = {
        0xBC, 0xBE, 0xAC, 0xB6, 0xB0, 0xFF, 0xFF, 0xFF, 0x9C, 0xCD, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFE, 0xFF, 0xEF, 0xFF, 0xFE, 0xFF,  _a3, _a2,  _a1,  _b,   0x00, 0x00, 0x00, 0x00, 0x00,
		0x43, 0x43, 0x30, 0x31, 0x30, 0x30, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x43, 0x50, 0x00, 0x00, 0x00,
		_c4,  _c3,  _c2,  _c1,  0x00, 0x00, 0x00, 0x09, _d4,  _d3,  _d2,  _d1,  0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x30, 0x30, _e4,  _e3,  _e2,  _e1,
		0x00, 0x00, _w2,  _w1,  _h2,  _h1,  0x00, 0x10, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, _f4,  _f3,  _f2,  _f1
    };

    //if(!(sizeof(header) == HEADER_LENGTH))
    //    return false;

    std::copy(header, header+HEADER_LENGTH, image_data);
    std::cout << "did header" << std::endl;
    return true;
}

bool C2PImage::CreateFooter(unsigned char* image_data) {
    //assert correct length
    if(m_compressed_data_size == 0)
        return false;

    unsigned char footer[] = {
        0x30, 0x31, 0x30, 0x30, 0x00, 0x00, 0x00, 0x8C, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x06, 0x28, 0x31, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x06, 0x28, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x31, 0x30, 0x30, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x01, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x14, 0x15, 0x93,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    };

    //can remove after first use
    //if(!(sizeof(footer) == FOOTER_LENGTH))
    //    return false;

    std::copy(footer, footer+FOOTER_LENGTH, image_data+HEADER_LENGTH+m_compressed_data_size);
    std::cout << "created footer" << std::endl;
    return true;
}

C2PImage::~C2PImage() {
    /*no idea if i should use free or delete[] here
      since i used malloc thought i would use c-style free*/
    std::cout << "deleted c2pimage instance" << std::endl;
    free(m_converted_image_data);
    free(m_formatted_data);
}