#include "zlib/zlib.h"

#include <iostream>
#include <fstream>
#include <algorithm>
#include "C2PImage.hpp"

#define MAX_WIDTH 0x136
#define MAX_HEIGHT 0x191
#define COLOUR_CHANNELS 3

#define HEADER_LENGTH 0xDC
#define FOOTER_LENGTH 0x17C
#define IMAGE_STARTOFFSET 0xDC

C2PImage::C2PImage(std::string image_path) 
: Image(image_path, COLOUR_CHANNELS, ImageFormat::PNG), m_compressed_data_size(0) { // format doesn't matter
    std::cout << "C2P: c2pimage class constructed" << std::endl;
}

bool C2PImage::ConvertToC2P(bool keep_aspect_ratio) {
    int resize_width = MAX_WIDTH;    
    int resize_height = MAX_HEIGHT;
    if(keep_aspect_ratio) {
        float aspect_ratio = (float)m_width / (float)m_height;
        if(aspect_ratio <= 0) aspect_ratio = 1; // fix a potential divide by zero

        resize_height = (int)((float)MAX_WIDTH / aspect_ratio);
    }

    if(!Resize(resize_width, resize_height)) {
        std::cerr << "ERR: image resize failed" << "\n";
        return false;
    }

    if(!ConvertRGB565()) {
        std::cerr << "ERR: image RGB565 conversion failed" << "\n";
        return false;
    }

    if(!CompressData()) {
        std::cerr << "ERR: c2pimage compression failed" << "\n";
        return false;
    }
    
    // allocate final data for header creation
    m_formatted_data = (uint8_t*)malloc(HEADER_LENGTH + m_compressed_data_size + FOOTER_LENGTH);

    if(!CreateHeader(m_formatted_data)) {
        std::cerr << "ERR: c2pimage header creation failed" << "\n";
        return false;
    } 

    //copy image data into final image
    std::copy(m_image_data, m_image_data+m_compressed_data_size, HEADER_LENGTH+m_formatted_data); 

    // no longer need this since am not double freeing
    // gets freed by Image base destructor
    //m_image_data = nullptr; pretty sure this leaked ~0.5GB of memory
    

    if(!CreateFooter(m_formatted_data)) {
        std::cerr << "ERR: c2pimage footer creation failed" << std::endl;
        return false;
    }
    return true;
}

bool C2PImage::Write(std::string f) {
    std::fstream output_file;
    std::string filename = f + ".c2p";

    output_file.open(filename, std::ios::out | std::ios::binary);
    output_file.write(reinterpret_cast<char*>(m_formatted_data), HEADER_LENGTH + m_compressed_data_size + FOOTER_LENGTH);

    output_file.close();
    std::cout << "C2P: wrote c2p file" << std::endl;
    return true;
}

bool C2PImage::ConvertRGB565() {
    int size = m_width * m_height * m_colour_channels;
    uint8_t* converted_image_data = (uint8_t*)malloc(m_width * m_height * 2);

    uint8_t red, green, blue;
    uint16_t final_byte;
    uint8_t final_byte_1, final_byte_2;

    int current_index, current_converted_index;
    for(int i = 0; i < m_height; i++) {
        for(int j = 0; j < m_width; j++) {
            //i moves you down the rows, j moves you across the columns
            current_index = i * m_width * m_colour_channels + j * m_colour_channels;

            //converted image data has 2 bytes for colour channels 
            current_converted_index = i * m_width * 2 + j * 2;

            //check if index goes outside pointer
            if(current_index + 2 > size) {
                return false;
            }

            red = m_image_data[current_index];
            green = m_image_data[current_index+1];
            blue = m_image_data[current_index+2];
            
            final_byte = ((red & 0b11111000) << 8)      // keep red top 5 bits and bitshift to leftmost
                        +((green & 0b11111100) << 3)    // green
                        +((blue & 0b11111000) >> 3);    //

            // converting to uint8_t for array
            final_byte_1 = (uint8_t)(final_byte & 0xFF);        // 0xFF ensures no numbers on leftmost byte 
            final_byte_2 = (uint8_t)((final_byte >> 8) & 0xFF); // bitshift right by 1 byte

            // new colour channel bytes is 2
            converted_image_data[current_converted_index] = final_byte_2;     // bottom byte
            converted_image_data[current_converted_index + 1] = final_byte_1; // top byte

            final_byte = 0;
            final_byte_1 = 0; 
            final_byte_2 = 0;
            red = 0;
            green = 0;
            blue = 0;
        }
    }
    free(m_image_data); // free old image data
    m_image_data = converted_image_data;
    converted_image_data = nullptr;

    std::cout << "C2P: converted to RGB565" << std::endl;
    return true;
}

bool C2PImage::CompressData() {
    int success = 0;
    int data_size = m_width * m_height * 2;
    uLongf alloc_size = (data_size * 1.1) + 12;// compression allocation size   
                                               // zlib needs x1.01 + 12 bytes, x1.1 for safety
                                               // this value becomes the new size after compress() call

    uint8_t* compressed_image_data = (uint8_t*)malloc(alloc_size);

    success = compress(compressed_image_data, /*casting this value to uLongf* caused much pain don't do it again*/&alloc_size, m_image_data, data_size);
    switch(success) {
        case Z_OK:
            break;
        case Z_MEM_ERROR:
            std::cerr << "ERR: ZLib ran out of memory\n";
            return false;
            break;
        case Z_BUF_ERROR:
            std::cerr << "ERR: ZLib output buffer too small\n";
            return false;
            break;
    }

    m_compressed_data_size = alloc_size;
    free(m_image_data); // free old data
    m_image_data = compressed_image_data;
    compressed_image_data = nullptr;

    std::cout << "C2P: compression successful" << std::endl;
    return true;
}

bool C2PImage::CreateHeader(uint8_t* image_data) {   
    uint32_t file_size = HEADER_LENGTH + m_compressed_data_size + FOOTER_LENGTH;

    // all of this is explained in .c2p file format documentation
    // that i found from TIPlanet
    uint32_t _a = ~(file_size & 0xFFFFFF) & 0xFFFFFF; // &ing prevents non-zero values in top byte
    uint8_t _a1 = (uint8_t)(_a & 0xFF);         // separate bytes of value
    uint8_t _a2 = (uint8_t)((_a >> 8) & 0xFF);  // 1-3 goes from bottom byte
    uint8_t _a3 = (uint8_t)((_a >> 16) & 0xFF); // to top byte

    uint8_t _b = (0x1D1 - (file_size & 0xFF)) & 0xFF;

    uint32_t _c = file_size - 0x20;
    uint8_t _c1 = (uint8_t)(_c & 0xFF);
    uint8_t _c2 = (uint8_t)((_c >> 8) & 0xFF);
    uint8_t _c3 = (uint8_t)((_c >> 16) & 0xFF);
    uint8_t _c4 = (uint8_t)((_c >> 24) & 0xFF);

    uint32_t _d = file_size - 0x234;
    uint8_t _d1 = (uint8_t)(_d & 0xFF);
    uint8_t _d2 = (uint8_t)((_d >> 8) & 0xFF);
    uint8_t _d3 = (uint8_t)((_d >> 16) & 0xFF);
    uint8_t _d4 = (uint8_t)((_d >> 24) & 0xFF);

    uint32_t _e = file_size - 0x254;
    uint8_t _e1 = (uint8_t)(_e & 0xFF);
    uint8_t _e2 = (uint8_t)((_e >> 8) & 0xFF);
    uint8_t _e3 = (uint8_t)((_e >> 16) & 0xFF);
    uint8_t _e4 = (uint8_t)((_e >> 24) & 0xFF);

    uint16_t _w = m_width & 0xFFFF;
    uint8_t _w1 = (uint8_t)(_w & 0xFF);
    uint8_t _w2 = (uint8_t)((_w >> 8) & 0xFF);

    uint16_t _h = m_height & 0xFFFF;
    uint8_t _h1 = (uint8_t)(_h & 0xFF);
    uint8_t _h2 = (uint8_t)((_h >> 8) & 0xFF);

    uint32_t _f = file_size - 0x258;
    uint8_t _f1 = (uint8_t)(_f & 0xFF);
    uint8_t _f2 = (uint8_t)((_f >> 8) & 0xFF);
    uint8_t _f3 = (uint8_t)((_f >> 16) & 0xFF);
    uint8_t _f4 = (uint8_t)((_f >> 24) & 0xFF);

    uint8_t* header = new uint8_t[HEADER_LENGTH]{
        0xBC, 0xBE, 0xAC, 0xB6, 0xB0, 0xFF, 0xFF, 0xFF, 0x9C, 0xCD, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFE, 0xFF, 0xEF, 0xFF, 0xFE, 0xFF,  _a3, _a2,  _a1,  _b,   0x00, 0x00, 0x00, 0x00, 0x00,
		0x43, 0x43, 0x30, 0x31, 0x30, 0x30, 0x43, 0x6F, 0x6C, 0x6F, 0x72, 0x43, 0x50, 0x00, 0x00, 0x00,
		_c4,  _c3,  _c2,  _c1,  0x00, 0x00, 0x00, 0x09, _d4,  _d3,  _d2,  _d1,  0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x31, 0x30, 0x30, _e4,  _e3,  _e2,  _e1,
		0x00, 0x00, _w2,  _w1,  _h2,  _h1,  0x00, 0x10, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
		0x00, 0x01, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, _f4,  _f3,  _f2,  _f1
    };

    // copy header (header start to end) to start of image data
    std::copy(header, header+HEADER_LENGTH, image_data);

    std::cout << "C2P: created header" << std::endl;
    delete header;
    return true;
}

bool C2PImage::CreateFooter(uint8_t* image_data) {
    // assert correct length
    if(m_compressed_data_size == 0)
        return false;

    // from .c2p file format document
    uint8_t* footer = new uint8_t[FOOTER_LENGTH]{
        0x30, 0x31, 0x30, 0x30, 0x00, 0x00, 0x00, 0x8C, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x07, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x60, 0x00, 0x04, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x06, 0x28, 0x31, 0x85, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x06, 0x28, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x98, 0x00, 0x00, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0x30, 0x31, 0x30, 0x30, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x03, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
		0x02, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x02, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x01, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00,
		0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x14, 0x15, 0x93,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03, 0x14, 0x15, 0x93, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
    };

    // copy footer (footer start to end) to start of image + header
    std::copy(footer, footer+FOOTER_LENGTH, image_data+HEADER_LENGTH+m_compressed_data_size);
    std::cout << "C2P: created footer" << std::endl;
    delete footer;
    return true;
}

C2PImage::~C2PImage() {
    //no idea if i should use free or delete[] here
    //since i used malloc thought i would use c-style free
    std::cout << "C2P: deleted c2pimage instance" << std::endl;
    free(m_formatted_data);
}